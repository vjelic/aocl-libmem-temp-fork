{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-78db7ee9-6466-4368-bad2-f0c5e9d6aa5c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-9910ec64-3408-406d-9e86-5652d2669220",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-6aa88551-d401-4604-9f33-1a10ebb2d9e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-3a112cca-49e8-4772-ae5b-92c963936cb8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-cb4be66d-6cc9-4ad6-9840-a0642db3fbe3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-203f96fe-9874-4fa7-ba14-9379f03d8936",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-16e97856-c9f6-425f-8758-bcc1cff0f18b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-5757c872-d0fd-49e0-a4b9-1fe4f644c6b1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-7eb6e80f-0617-4003-b4bd-2229cef8882b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially when randomness is required for security purposes. The `rand()` function, which relies on `RAND_MAX`, is a common example of a non-cryptographic random number generator. It is predictable and not suitable for cryptographic purposes, such as generating keys, tokens, or any other security-sensitive data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which are more suitable for generating random numbers in a secure manner.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here's an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++11-compliant compiler.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-493c0581-260a-4db2-b9fb-df4e807953f4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e128afe0-82a3-4c83-aa99-dae04d933188",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C++ is used to concatenate a specified number of characters from one string to another. However, it is considered unsafe because it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, which are a common vulnerability in C++ programs. The specific vulnerability occurs when `strncat` is used without proper bounds checking, potentially allowing an attacker to overwrite adjacent memory and execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string manipulation functions like `strncpy_s` or `strlcat` (if available) that ensure null-termination and provide better bounds checking.\n2. **Manual Bounds Checking**: Always perform manual bounds checking to ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and fix unsafe string operations.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy_s`, which is a safer alternative:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t buffer_size = 256;\n    char page_alnd_addr[buffer_size] = {0};\n    const char* needle = \"example\";\n    size_t needle_len = strlen(needle);\n\n    // Ensure that the destination buffer is large enough\n    if (needle_len < buffer_size) {\n        strncpy_s(page_alnd_addr, buffer_size, needle, needle_len);\n        page_alnd_addr[needle_len] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Error: Buffer overflow risk detected!\" << std::endl;\n    }\n\n    std::cout << \"Result: \" << page_alnd_addr << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following standard library:\n\n- `<cstring>`: For string manipulation functions.\n- `<iostream>`: For input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-b547d5c1-36ff-4139-908e-0f2ed21e438d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C/C++ is used to concatenate a specified number of characters from one string to another. However, it can lead to vulnerabilities if not used carefully, particularly buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the concatenated result, potentially allowing attackers to overwrite adjacent memory and execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string manipulation functions such as `strlcat` (if available) or C++ string classes like `std::string` which handle memory management automatically.\n2. **Proper Buffer Sizing**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Explicit Null Termination**: Always ensure that the destination string is null-terminated after concatenation.\n4. **Bounds Checking**: Perform explicit bounds checking before concatenation to prevent buffer overflow.\n\n### Source Code Fix Recommendation\n\nBelow is a fixed version of the vulnerable code using `strncat`. The fix ensures that the destination buffer is large enough and properly null-terminated.\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 256; // Define a buffer size\n    char str1_alnd_addr[bufferSize] = \"Hello, \";\n    char str3_alnd_addr[] = \"World!\";\n    size_t size = sizeof(str3_alnd_addr) - 1; // Exclude null terminator\n\n    // Ensure the destination buffer has enough space for the concatenated result\n    if (strlen(str1_alnd_addr) + size < bufferSize) {\n        strncat(str1_alnd_addr, str3_alnd_addr, size);\n        str1_alnd_addr[bufferSize - 1] = '\\0'; // Explicitly null-terminate\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << str1_alnd_addr << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncat`.\n- `<iostream>`: Required for input/output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-de831fc6-a77f-49e3-a765-012b34bba68e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-cdbfdf65-03b7-49cf-9df0-d65505bd9c74",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-127807b1-d562-4826-a428-f4e1c9f89acb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C/C++ is used to concatenate a specified number of characters from one string to another. However, it can lead to vulnerabilities if not used carefully, particularly buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the concatenated result, potentially allowing attackers to overwrite adjacent memory and execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string manipulation functions such as `strlcat` (if available) or C++ string classes like `std::string` which handle memory management automatically.\n2. **Proper Buffer Sizing**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Explicit Null Termination**: Always ensure that the destination string is null-terminated after concatenation.\n4. **Bounds Checking**: Perform explicit bounds checking before concatenation to prevent buffer overflow.\n\n### Source Code Fix Recommendation\n\nBelow is a fixed version of the vulnerable code using `strncat`. The fix ensures that the destination buffer is large enough and properly null-terminated.\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 256; // Define a buffer size\n    char str1_alnd_addr[bufferSize] = \"Hello, \";\n    char str3_alnd_addr[] = \"World!\";\n    size_t size = sizeof(str3_alnd_addr) - 1; // Exclude null terminator\n\n    // Ensure the destination buffer has enough space for the concatenated result\n    if (strlen(str1_alnd_addr) + size < bufferSize) {\n        strncat(str1_alnd_addr, str3_alnd_addr, size);\n        str1_alnd_addr[bufferSize - 1] = '\\0'; // Explicitly null-terminate\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << str1_alnd_addr << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncat`.\n- `<iostream>`: Required for input/output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-8dbc49a8-9309-438c-9ef0-a4de2237531c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c55e29d4-1635-457b-a948-1f174bdb7fc7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-2ac7b43d-a491-406e-87cd-42b166e9e47b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C/C++ is used to concatenate a specified number of characters from one string to another. However, it can lead to vulnerabilities if not used carefully, particularly buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the concatenated result, potentially leading to memory corruption, crashes, or security breaches.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string manipulation functions like `strncpy_s` or `strlcat` if available, which provide better bounds checking.\n2. **Proper Buffer Sizing**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Manual Bounds Checking**: Always manually check the size of the destination buffer before performing concatenation to prevent overflow.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that uses `strncat`:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t bufferSize = 100;\n    char str1_alnd_addr[bufferSize] = \"Hello, \";\n    char str2_alnd_addr[] = \"World!\";\n    size_t size = sizeof(str2_alnd_addr) - 1; // Exclude null terminator\n\n    // Ensure there is enough space in str1_alnd_addr for concatenation\n    if (strlen(str1_alnd_addr) + size < bufferSize) {\n        strncat(str1_alnd_addr, str2_alnd_addr, size);\n    } else {\n        std::cerr << \"Buffer overflow risk, concatenation aborted.\" << std::endl;\n    }\n\n    std::cout << str1_alnd_addr << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard library is required:\n\n- `<cstring>`: For string manipulation functions.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-752e1b57-e685-4659-8f01-edccec3cc901",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-000a774b-7a62-496a-8c8c-a2726e6ed77c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1536240b-aae2-477f-85b2-2204136f002d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-02d9d9ba-df43-4c05-a9ac-abcd7bd60506",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C/C++ is used to concatenate a specified number of characters from one string to another. However, it can lead to vulnerabilities if not used carefully, particularly buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the concatenated result, potentially leading to memory corruption, crashes, or security breaches.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string manipulation functions like `strncpy_s` or `strlcat` if available, which provide better bounds checking.\n2. **Proper Buffer Sizing**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Manual Bounds Checking**: Always manually check the size of the destination buffer before performing concatenation to prevent overflow.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that uses `strncat`:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t bufferSize = 100;\n    char str1_alnd_addr[bufferSize] = \"Hello, \";\n    char str2_alnd_addr[] = \"World!\";\n    size_t size = sizeof(str2_alnd_addr) - 1; // Exclude null terminator\n\n    // Ensure there is enough space in str1_alnd_addr for concatenation\n    if (strlen(str1_alnd_addr) + size < bufferSize) {\n        strncat(str1_alnd_addr, str2_alnd_addr, size);\n    } else {\n        std::cerr << \"Buffer overflow risk, concatenation aborted.\" << std::endl;\n    }\n\n    std::cout << str1_alnd_addr << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard library is required:\n\n- `<cstring>`: For string manipulation functions.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-b6d4205a-2314-4ca4-bfe0-4c655c9b1daa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d2476d55-6316-4beb-8529-6e4d2b3cb6cf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcat)\" vulnerability arises when the `strcat` function is used in C++ programming. This function is inherently unsafe because it does not perform bounds checking, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcat` with `strncat` or `std::string` to prevent buffer overflow:\n\n```cpp\n#include <cstring>  // For strncat\n#include <string>   // For std::string\n\nvoid safeConcatenate(char* dest, size_t destSize, const char* src) {\n    // Using strncat with explicit bounds checking\n    strncat(dest, src, destSize - strlen(dest) - 1);\n}\n\nvoid safeConcatenate(std::string& dest, const std::string& src) {\n    // Using std::string for safer concatenation\n    dest.append(src);\n}\n```\n\n### Library Dependencies\n\nFor the code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: Provides the `strncat` function.\n- `<string>`: Provides the `std::string` class and its methods.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-9c5e2b8a-683f-4cbd-991c-00dafdfa0f3a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-3a36f036-aaec-4c09-b259-ceeeaa450d2d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e252d2a3-4472-47f2-943b-3182f2dea273",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcat)\" vulnerability arises when the `strcat` function is used in C++ programming. This function is inherently unsafe because it does not perform bounds checking, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcat` with `strncat` or `std::string` to prevent buffer overflow:\n\n```cpp\n#include <cstring>  // For strncat\n#include <string>   // For std::string\n\nvoid safeConcatenate(char* dest, size_t destSize, const char* src) {\n    // Using strncat with explicit bounds checking\n    strncat(dest, src, destSize - strlen(dest) - 1);\n}\n\nvoid safeConcatenate(std::string& dest, const std::string& src) {\n    // Using std::string for safer concatenation\n    dest.append(src);\n}\n```\n\n### Library Dependencies\n\nFor the code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: Provides the `strncat` function.\n- `<string>`: Provides the `std::string` class and its methods.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-6bf82bfb-bba3-4ed0-802a-21f6d5bda9f5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-807876b3-270b-47d0-bd5b-7d545515864f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-09e49a80-318c-4fdc-a629-2874099f7c92",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-bfa7a197-bf32-4bf0-86cd-2430dea179b5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0f80f074-671b-46ce-8ec4-ba8d166aa4d4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d45204f9-1b65-44c0-aa51-e7475ac89b1f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-a0f579e9-cd2f-4c46-8e6e-4d1ab20f5751",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcat)\" vulnerability arises when the `strcat` function is used in C++ programming. This function is inherently unsafe because it does not perform bounds checking, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcat` with `strncat` or `std::string` to prevent buffer overflow:\n\n```cpp\n#include <cstring>  // For strncat\n#include <string>   // For std::string\n\nvoid safeConcatenate(char* dest, size_t destSize, const char* src) {\n    // Using strncat with explicit bounds checking\n    strncat(dest, src, destSize - strlen(dest) - 1);\n}\n\nvoid safeConcatenate(std::string& dest, const std::string& src) {\n    // Using std::string for safer concatenation\n    dest.append(src);\n}\n```\n\n### Library Dependencies\n\nFor the code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: Provides the `strncat` function.\n- `<string>`: Provides the `std::string` class and its methods.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-a313c37c-b98c-433d-a268-b004a327b716",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b26e54d7-c5e1-4439-abe3-663b09d2dbdd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-4e25b2dd-d033-4856-8ddd-2864e8906364",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcat)\" vulnerability arises when the `strcat` function is used in C++ programming. This function is inherently unsafe because it does not perform bounds checking, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcat` with `strncat` or `std::string` to prevent buffer overflow:\n\n```cpp\n#include <cstring>  // For strncat\n#include <string>   // For std::string\n\nvoid safeConcatenate(char* dest, size_t destSize, const char* src) {\n    // Using strncat with explicit bounds checking\n    strncat(dest, src, destSize - strlen(dest) - 1);\n}\n\nvoid safeConcatenate(std::string& dest, const std::string& src) {\n    // Using std::string for safer concatenation\n    dest.append(src);\n}\n```\n\n### Library Dependencies\n\nFor the code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: Provides the `strncat` function.\n- `<string>`: Provides the `std::string` class and its methods.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-c9ae943b-4477-4442-80f3-3be9fe51f17b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-7d3246cf-3498-4197-8373-1d36824f4913",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0d4de2ca-8b08-469e-a003-8733f9321185",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-098a2509-64af-4bff-a96e-9c3b55a8b9fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-2f71e7bb-e207-42d2-821a-f4d2fd4eb8df",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-7b63ad1a-05bd-4266-b0fe-d0e706ffc9a5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e811a1fe-95f4-46d7-87ea-4787292ff9c9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of `strlen((char *)` in C++ arises from the potential for buffer overflows and undefined behavior when the function is used improperly. The `strlen` function calculates the length of a C-style string by searching for the null terminator (`'\\0'`). If the input is not properly null-terminated or if it points to an invalid memory location, this can lead to reading beyond the buffer's bounds, causing security vulnerabilities such as information leakage, crashes, or even arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input strings are properly null-terminated before passing them to `strlen`.\n2. **Buffer Size Management**: Always allocate sufficient buffer size to accommodate the string and the null terminator.\n3. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage buffer sizes and null-termination, such as `std::string` in C++.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nInstead of using `strlen((char *)`, consider using `std::string` for safer string handling. Here's an example of how you can refactor the code:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string myString = \"Hello, World!\";\n    size_t length = myString.length(); // Safe alternative to strlen\n    std::cout << \"Length of the string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library is required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c6618f7b-c608-4070-80c3-0dcdaee34e1a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-f49f8302-0067-40db-9d08-144371f57a02",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-16a63ca8-b1be-4ad7-8935-69b91608ca55",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of `strlen((char *)` in C++ arises from the potential for buffer overflows and undefined behavior when the function is used improperly. The `strlen` function calculates the length of a C-style string by searching for the null terminator (`'\\0'`). If the input is not properly null-terminated or if it points to an invalid memory location, this can lead to reading beyond the buffer's bounds, causing security vulnerabilities such as information leakage, crashes, or even arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input strings are properly null-terminated before passing them to `strlen`.\n2. **Buffer Size Management**: Always allocate sufficient buffer size to accommodate the string and the null terminator.\n3. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage buffer sizes and null-termination, such as `std::string` in C++.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nInstead of using `strlen((char *)`, consider using `std::string` for safer string handling. Here's an example of how you can refactor the code:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string myString = \"Hello, World!\";\n    size_t length = myString.length(); // Safe alternative to strlen\n    std::cout << \"Length of the string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library is required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-cacb2cf9-85f1-4108-99fa-fa90c5eb38fe",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-a1eaaf9f-cf5f-4b75-b4c9-1a8ea50d892b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-813bdc26-4ef8-408d-89ef-2f6deb6bb89f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-59b7e0ea-1b67-48a4-8f98-b9b9cdf0bd74",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d99b82dc-8e43-4a59-b67d-cb36496e05ec",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-708b8d3c-e125-4091-9a1b-cf2b62aae6c3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-1eca9e53-577d-4502-83e0-e223a5ea1935",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e65754c8-b351-4110-adbc-7cbc13b8f9a2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-32ce2496-6514-4d33-94b4-0c3de1fc9c95",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-945dd2c1-ae5a-43df-a73d-bbf5de66ab2b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d4dbc3cb-7a1f-4e64-ac52-6eb00acf16a8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-24bfd7ef-6ad3-4b61-b51d-9532a8432488",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-8462d550-8837-45a9-b33a-37347022c874",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-cbcc1f26-e712-45ee-9a3f-d008508c53ea",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-bbcb6730-6f67-4c4b-b57b-8c35899b2457",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-e7e54843-22a7-422a-b5f4-e39a8763bf79",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-3f1e118c-d483-4619-a33a-df466f866958",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-dfe3a0e5-400e-445a-9aef-86d8c57a7ca8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-1a1867ff-aa23-4840-80da-d585c49d02ba",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-3b469947-329d-40ae-b676-32d13a534ae0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-5e93d54d-cfb5-4002-b8d3-69dedd18506a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-0815c78b-a1a4-4d1b-ab40-7ba9d727c244",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-9263db72-5961-48ec-bb76-c92ea1d5ad83",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-bb1bd29f-6b81-416d-962d-7bb3e8148ba9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1c04e29a-396f-4b31-93bc-30dc8040b4c8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-252d9842-78ae-4eda-a7f4-38a7fbe71a13",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-416fdb34-3d3d-47c7-9933-92e7b4e5663f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-79216bf9-be48-485c-81b3-15698c38eab8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-40697189-ae7f-47b7-bc16-51634f151e8c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-dbf2ad9e-ca17-407a-b924-9057cee76f10",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-01abcc3f-efc1-4ff7-8569-31775e074c44",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e1ff085d-38af-4740-b7f9-0dc34476507b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-76110344-70bd-4855-aa62-8b7d7db68774",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-fe4501b9-e7c7-4326-9eb1-2068e6f26685",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-f40b19d9-5946-4fd7-adec-d6b9b5576622",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8007dd79-edb0-4dd8-a04d-63034fb6b829",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-6fa5d2d3-c9ec-4cba-aa08-70099ebf7ab5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-ddf8be51-d3d3-42d4-8b36-a96f71921d7c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e5197feb-17fa-45cf-9e00-b21e36707431",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-50e30333-ca97-4ab5-9570-9029f309aff4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-68ef2bfc-d8ac-438e-bee3-0600e1db08d5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-82d7f5da-1ef1-4c95-8cfc-d74ed8de0f14",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-16852f02-8659-4ebf-848e-cfdf9a0f0eb8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-062931e7-798e-4b57-a436-61e41fb5de83",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b9ce516d-5b5a-465d-8724-e1393a89c793",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-88dcc73c-5af0-410d-8b01-08a742c9a2d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8efdfe50-275c-45b6-99b1-54027ed5330c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-03b5e81f-7061-4f8b-95a7-c4ce8cc0b5cf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-947ed0e9-7e6f-4552-a5e8-0b32a315dea0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-84d98822-45f7-4a0a-a622-8fd5ed8bad9f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-cde5ee48-1327-4937-b598-5267838110ce",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-31a1d370-2ca6-4235-9a17-1c6ab46a5f29",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen((char*)` function in C++ arises from its inability to handle non-null-terminated strings. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the string is not properly null-terminated, `strlen` may read beyond the intended buffer, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen((char*)`, ensure that the string is properly null-terminated before calling `strlen`. Alternatively, use `std::string` which manages its own length.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(char* input) {\n    size_t length = strlen(input); // Potentially unsafe if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string& input) {\n    size_t length = input.length(); // Safe as std::string manages its own length\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard libraries are required:\n\n- `<cstring>`: For C-style string functions (used in the vulnerable example).\n- `<iostream>`: For input/output stream operations.\n- `<string>`: For using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-ea667f2d-eadf-496e-84c6-4011bdc962f7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0712455c-5966-4033-aa34-e98b08508adc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    std::string str2 = \"example\"; // Use std::string to ensure null-termination\n    size_t length = str2.length(); // Use std::string's length method\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required if using C-style strings and `strlen`.\n- `<string>`: Required for using `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d1805eeb-a035-4380-a615-d057c0498b6f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-53158b4d-1c61-4135-a125-dcc78a337a36",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when dealing with user-supplied input, as it can lead to security vulnerabilities such as buffer overflow attacks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically handle null-termination and buffer sizes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with using `strlen`, ensure that the input string is properly null-terminated and within expected bounds before calling `strlen`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint safe_strlen(const char* str, size_t max_length) {\n    if (str == nullptr) {\n        return 0; // Handle null pointer\n    }\n    size_t length = 0;\n    while (length < max_length && str[length] != '\\0') {\n        ++length;\n    }\n    return length;\n}\n\nint main() {\n    const char* str1 = \"Hello, World!\";\n    size_t max_length = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(str1, max_length);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links were verified to be active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c83d0499-599c-4b7b-84f4-df68a3a3c96c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-baf6fa9f-b283-4cd2-9582-e88a3aa79e3e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-33307925-3b63-40ca-bb71-78509f9e3636",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-deacd0d6-446c-4b6a-b77f-174075990e73",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-f69aaf66-3fac-4c65-a1b6-2e04314d9f1c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually ensure that the destination buffer is null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your codebase.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that ensures null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    if (destSize > 0) {\n        strncpy(dest, src, destSize - 1);\n        dest[destSize - 1] = '\\0'; // Ensure null-termination\n    }\n}\n\n// Usage\nchar str1_alnd_addr[] = \"source string\";\nchar str2_alnd_addr[20]; // Ensure this buffer is large enough\nsafeCopy(str2_alnd_addr, str1_alnd_addr, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0a9ed056-5e98-4b32-9902-1d4c242b7c89",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-9815a51d-1d13-4db5-b071-58cbd7b8f586",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-618c1081-6e3f-4ed5-bce6-6e7c9c8f86ef",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-154bce13-0965-4330-8ce2-5d5b61ca420c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-df509bf1-8100-4c95-aecc-f27ad4c522d1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually ensure that the destination buffer is null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your codebase.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that ensures null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    if (destSize > 0) {\n        strncpy(dest, src, destSize - 1);\n        dest[destSize - 1] = '\\0'; // Ensure null-termination\n    }\n}\n\n// Usage\nchar str1_alnd_addr[] = \"source string\";\nchar str2_alnd_addr[20]; // Ensure this buffer is large enough\nsafeCopy(str2_alnd_addr, str1_alnd_addr, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-afb43118-9ec8-4055-9c84-5277f9f215f3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually ensure that the destination buffer is null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your codebase.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that ensures null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    if (destSize > 0) {\n        strncpy(dest, src, destSize - 1);\n        dest[destSize - 1] = '\\0'; // Ensure null-termination\n    }\n}\n\n// Usage\nchar str1_alnd_addr[] = \"source string\";\nchar str2_alnd_addr[20]; // Ensure this buffer is large enough\nsafeCopy(str2_alnd_addr, str1_alnd_addr, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-d02aaa0d-86e3-45a9-9f7b-3ce70ec1f0cd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-502210a8-5067-4c4c-a5dd-2dc109b5756f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-2076439b-5c52-48d7-8f03-3eb4ad31f48f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination string after using `strncpy`.\n3. **Bounds Checking**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that ensures null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t size) {\n    if (size > 0) {\n        strncpy(dest, src, size - 1);\n        dest[size - 1] = '\\0'; // Ensure null-termination\n    }\n}\n\n// Usage\nchar str1_alnd_addr[] = \"source string\";\nchar str2_alnd_addr[20]; // Ensure this is large enough\nsafeCopy(str2_alnd_addr, str1_alnd_addr, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c4a22317-1485-44f5-b58b-48c1700b50e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ code. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string and the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is properly sized and that the length of the copy is limited to the size of the destination buffer minus one to accommodate the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    // Use strncpy to copy with bounds checking\n    strncpy(dest, src, destSize - 1);\n    // Ensure null termination\n    dest[destSize - 1] = '\\0';\n}\n\n// Example usage\nchar str2_alnd_addr[100];\nconst char* source = \"This is a safe copy example.\";\nsafeCopy(str2_alnd_addr, source, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-fbdbd077-7dc9-452f-aae1-9fde4cf6814a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-8efe9829-7fe1-4817-9735-477189ca59b3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c6a9df7c-3bfe-4568-a9a6-6bf3a8d71ea4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ code. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string and the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is properly sized and that the length of the copy is limited to the size of the destination buffer minus one to accommodate the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    // Use strncpy to copy with bounds checking\n    strncpy(dest, src, destSize - 1);\n    // Ensure null termination\n    dest[destSize - 1] = '\\0';\n}\n\n// Example usage\nchar str2_alnd_addr[100];\nconst char* source = \"This is a safe copy example.\";\nsafeCopy(str2_alnd_addr, source, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-764d89f8-fa96-4ad8-b60d-7643b26e5f2b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c4ade2ca-8ae5-444e-b937-9082b5896987",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e4127223-bc6f-4999-be4e-fe4944792eb4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ code. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program to crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string and the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is properly sized and that the length of the copy is limited to the size of the destination buffer minus one to accommodate the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dest, const char* src, size_t destSize) {\n    // Use strncpy to copy with bounds checking\n    strncpy(dest, src, destSize - 1);\n    // Ensure null termination\n    dest[destSize - 1] = '\\0';\n}\n\n// Example usage\nchar str2_alnd_addr[100];\nconst char* source = \"This is a safe copy example.\";\nsafeCopy(str2_alnd_addr, source, sizeof(str2_alnd_addr));\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-0a1b37ad-36b0-4e13-8b3e-dd0d4c42dfab",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b66b0dae-ee9b-42af-8983-9563d5344fde",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-36d86c33-b50c-454a-b84b-e462f24d71e3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-8b1a6d53-248a-4c2b-9747-d0620dd1e6a6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-733794d7-6002-432d-a368-c18ad6fe8d9d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-baed24e2-3821-49f8-b0ed-35836575d629",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-5c319af9-9218-4bc9-8cd8-7f76878e69ad",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-96522093-cdae-48c6-8acb-2fc9aeda8a1e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e86d5537-f1a8-4b97-9b02-8f72e7f7bc0b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-db2a717b-8552-49d1-a302-f4fa19c37321",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-96322584-3e44-4c69-bc22-bd9e62978956",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-8485d2f2-dae4-41bf-b362-7f13211c2ee5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-bca4736b-208e-48f0-b9b5-700c73a92c56",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-bd237c7d-bd80-4454-9bef-fc8ea366f735",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-08dd842b-fd1c-4b26-9f31-54c4d4808295",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-5ef170a7-2b53-4440-bc75-6d80a64b0344",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied from the source buffer, or when the source and destination buffers overlap, which `memcpy` does not handle correctly.\n\n### General Mitigation Advice\n\n1. **Buffer Size Verification**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if there is a possibility of overlapping buffers, or higher-level abstractions like `std::copy` in C++ which provide bounds checking.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other memory-related issues in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch improper use of memory functions.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code using `memmove` to handle potential overlapping buffers:\n\n```cpp\n#include <cstring> // Required for memmove\n\nvoid safeCopy(void* dst_alnd_addr, const void* src_alnd_addr, size_t size, size_t dst_size) {\n    if (dst_size >= size) {\n        memmove(dst_alnd_addr, src_alnd_addr, size);\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<cstring>`: This library is required for the `memmove` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8b2f6416-2cd8-491d-8752-e47a2de22287",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-64a80e19-1415-40f8-9d36-48be44f72d16",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1f367c46-ab6f-49ba-9f8e-1542223d0cce",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied from the source buffer, or when the source and destination buffers overlap, which `memcpy` does not handle correctly.\n\n### General Mitigation Advice\n\n1. **Buffer Size Verification**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if there is a possibility of overlapping buffers, or higher-level abstractions like `std::copy` in C++ which provide bounds checking.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other memory-related issues in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch improper use of memory functions.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code using `memmove` to handle potential overlapping buffers:\n\n```cpp\n#include <cstring> // Required for memmove\n\nvoid safeCopy(void* dst_alnd_addr, const void* src_alnd_addr, size_t size, size_t dst_size) {\n    if (dst_size >= size) {\n        memmove(dst_alnd_addr, src_alnd_addr, size);\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<cstring>`: This library is required for the `memmove` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ba4e961b-f2a3-44eb-8f01-e9066ba40279",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-ac29bc0f-e7a2-4ba2-bf4a-051f199265b9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1c67813c-1f9d-4a68-a7bc-37bcfdb938c8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-ce63cb04-a66f-40bd-86d5-28afe43cf881",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b4c03f0d-1d33-421f-93da-12ad7d037b6c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d7d5ac76-1a7b-4fdc-bcad-b89caa8c5a34",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-cf1501a6-2035-4347-880b-18e8e47334a4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-3fd5495f-8520-4d64-a564-8b8d4b401a77",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d70ecc50-0473-4338-96c3-b031644505eb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-29619e8d-ea63-4414-955c-bdf667a2e9a7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-232a4b03-9c22-447b-ad5c-a564ee8775b2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0a2cae6a-cb32-43ca-98d6-292fc851a984",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c92faa20-fc1f-43ec-8cb5-ed575b5feada",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strncat` function in C/C++ is used to concatenate a specified number of characters from one string to the end of another. However, improper use of `strncat` can lead to vulnerabilities such as buffer overflow if the destination buffer is not large enough to hold the resulting string. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `strlcat` (if available) or C++ string classes (`std::string`) which handle memory management automatically.\n3. **Input Validation**: Validate input sizes before performing concatenation to ensure they do not exceed buffer limits.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncat`:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t bufferSize = 100;\n    char haystack[bufferSize] = \"Hello, \";\n    const char* needle = \"World!\";\n    size_t i = 6; // Number of characters to concatenate\n\n    // Ensure that the buffer has enough space for the concatenated result\n    if (strlen(haystack) + i < bufferSize - 1) {\n        strncat(haystack, needle, i);\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << haystack << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard libraries are required:\n\n- `<cstring>`: For C-style string manipulation functions.\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-ba9e4300-a6da-4ecf-9b30-045037bb8ee3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-85db9601-1e71-4900-b9cf-ee5b264190b9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-cd81430b-cd9d-4e10-a12a-c5cb998343cb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0e29f830-0871-4bab-9382-bdadaf526e34",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1eb02f89-ca3a-4ecb-b0d8-4dab083449e5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) provided by the C++ standard library, such as those found in `<random>`. These generators are designed to produce sequences of numbers that are not easily predictable, even if part of the sequence is known.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a CSPRNG from the `<random>` library. Below is an example of how to replace `rand() %` with a secure alternative:\n\n```cpp\n#include <random>\n#include <iostream>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for the random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Equivalent to rand() % 100\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<random>`: Provides facilities for random number generation.\n- `<iostream>`: Used for input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-e2894065-1de1-4a33-b7d0-27de503d3f38",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-30aa39b1-d4e3-4027-9737-45e4aa7f17c1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8f9c3534-6aa7-4541-908d-db03854bf7b6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-b8887eb6-63db-4408-9e3e-71e8a9a13b96",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-abb6ef0c-3eff-477b-8c0e-967783410b45",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-90ef4c0e-2464-4405-994a-d243c1e347fd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-a2b4ebae-9f4f-47c7-8ea3-a119ed8d417b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-5a8f1746-d6f0-463f-944e-d5be10bbcf9a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-5317d534-3d15-4baa-8e49-9103bbce410c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-58bb0a7d-c839-43fe-b6b7-40c39ad5acd3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-523b8c53-105d-4e72-a739-b43fc60bf43f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-54669c5c-2e2c-456f-8e20-4ef60fe88463",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f672b1c1-096b-4507-9f12-0ee4950ebcb6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-bba086ac-983c-40f8-b225-8f128f514b8b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8d0c5827-0095-4f43-83a6-ef5955182198",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-9640b4e1-bc0f-4089-9ce5-98224b4c19e6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-64e3f6a0-d854-4516-aa28-5dcb58832957",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-98f1cfdd-d2b6-49e9-a0e9-92fd6b6752c5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-041795f5-dbab-4595-8f74-f3feca9f7962",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-8751b201-9db5-44f6-a610-f2415baf5165",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-6e4372a5-7cfb-46ce-a4fb-07badcfb3f5d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b2e77615-f1ba-44fe-8524-4723821f150d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-35b0ed97-d845-4688-a266-95142a9cc497",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-7f5c9e2f-8e4d-4cc8-814e-d8666f00e9fc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-41ec271c-af89-4011-bbeb-7b5403880787",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-c3079594-390e-455a-9c2a-47069acc9cf3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-09716415-a345-4896-a23c-bab69f48ede4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-85c617ce-6f19-43ff-9594-dfbd0e000fc0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fbbd28db-58c8-40e5-ad18-0879cbd2f703",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-fe44d8bc-d4a8-4423-955b-8498f88d3c44",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-cf8d5aa5-f1ab-4fda-b60b-af6ac5592a1f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0026fe4a-243f-476a-b007-e20001ef84d6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-4376c0e3-4bc2-4bd9-8579-53ffa146c3e6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-ec36fce4-fc2a-4f7a-9b47-b4c02901a5af",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-9844e888-15bf-432a-b16d-eb38b3a3319a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b63f5563-be59-4b0d-94e5-916286823474",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0ba6aaff-c896-47c7-9f40-ca16eed8de3e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-49dc6da2-3d13-490c-983c-fe6529d15377",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6ba44cd6-79f5-45ad-9798-631b98f2e85a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-3bc87ec3-edef-459e-bdb4-ae6fcba404ac",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-a335c402-f937-48c2-852a-62967eb05523",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-6224e9aa-253f-47ec-8871-4a5ab3403060",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncat)\" vulnerability arises from the improper use of the `strncat` function in C++. This function is used to concatenate strings, but it can lead to buffer overflow if not used carefully. The function appends a specified number of characters from a source string to a destination string, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strncpy_s` or `strlcat` if available, which provide better control over buffer sizes and null-termination.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null-terminator.\n3. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncat`.\n4. **Input Validation**: Validate input lengths before performing concatenation to ensure they do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to fix the vulnerability by ensuring proper buffer management and null-termination:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const size_t BUFFER_SIZE = 50;\n    char destination[BUFFER_SIZE] = \"Hello, \";\n    const char* source = \"World!\";\n    size_t num = 6; // Number of characters to append\n\n    // Ensure the destination buffer has enough space\n    if (strlen(destination) + num < BUFFER_SIZE) {\n        strncat(destination, source, num);\n        destination[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n    } else {\n        std::cerr << \"Buffer overflow risk, operation aborted.\" << std::endl;\n    }\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<cstring>`: For string manipulation functions like `strncat` and `strlen`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-e50a81b3-c90b-4f67-9526-77b188ab3ef5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function is inherently unsafe because it does not perform bounds checking on the destination buffer. If the source string is larger than the destination buffer, it can lead to buffer overflow, which can be exploited to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy` (if available), or C++ string handling functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate input lengths before copying to ensure they do not exceed buffer sizes.\n4. **Use C++ Strings**: Prefer using `std::string` for string manipulations, which automatically manage memory and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcpy` with `strncpy` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncpy\n#include <iostream> // Required for std::cout\n\nvoid safeCopy(char *destination, const char *source, size_t destSize) {\n    // Use strncpy to ensure no buffer overflow\n    strncpy(destination, source, destSize - 1);\n    // Ensure null termination\n    destination[destSize - 1] = '\\0';\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"HelloWorld\";\n\n    safeCopy(destination, source, bufferSize);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-723af476-f42a-4340-bfbc-94d268a959b9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen(const char *)` function in C++ arises from its inability to handle strings that are not null-terminated. If `strlen` is called on a string that does not have a null terminator, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string lengths and memory.\n\n### General Mitigation Advice\n\n1. **Ensure Null Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that manage string lengths explicitly, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer is not read beyond its allocated size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstring>\n\nvoid processString(const char *input) {\n    size_t length = strlen(input); // Potential vulnerability if input is not null-terminated\n    // Further processing...\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid processString(const std::string &input) {\n    size_t length = input.length(); // Safe usage with std::string\n    // Further processing...\n}\n\nint main() {\n    std::string safeInput = \"Hello, World!\";\n    processString(safeInput);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nFor the fixed code example to execute properly, the following standard library is required:\n\n- `<iostream>`\n- `<string>`\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-959c80fb-7a67-4d3a-99f5-ac147c996ab8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            },
            {
              "id": "glog-e7ea47f1-3b30-4ef4-9774-7f1b21da403a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is intended to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities if the destination buffer is used without proper null-termination.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination of the destination buffer.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate the use of unsafe functions.\n\n### Source Code Fix Recommendation\n\nBelow is a code example demonstrating how to replace `strncpy` with a safer alternative:\n\n```cpp\n#include <cstring>  // Required for strlcpy\n\nvoid safeCopy(char *dest, const char *src, size_t destSize) {\n    // Use strlcpy to ensure null-termination\n    strlcpy(dest, src, destSize);\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char destination[bufferSize];\n    const char *source = \"Hello, World!\";\n\n    safeCopy(destination, source, bufferSize);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for string manipulation functions like `strlcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-cf72d9d3-2602-4ae0-b192-7a403b2fb1e9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size parameter is incorrect. Such vulnerabilities can lead to undefined behavior, crashes, or security issues like data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues in your code.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to safely use `memcpy`:\n\n```cpp\n#include <cstring>  // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const size_t bufferSize = 10;\n    char source[bufferSize] = \"Hello\";\n    char destination[bufferSize];\n\n    // Ensure that the size does not exceed the destination buffer\n    size_t sizeToCopy = std::min(strlen(source) + 1, bufferSize);\n\n    // Safe use of memcpy\n    memcpy(destination, source, sizeToCopy);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ff8b87bf-a676-4274-98d5-3f8c82e2e188",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcat)\" vulnerability arises from the use of the `strcat` function in C++. This function is used to concatenate two strings, but it does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the destination buffer is not large enough to hold the resulting concatenated string. Buffer overflows can be exploited to execute arbitrary code, cause a program crash, or corrupt data, making this a critical security issue.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcat` with safer alternatives like `strncat` or C++ string handling functions such as `std::string::append`.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace `strcat` with `strncat` to mitigate the vulnerability:\n\n```cpp\n#include <cstring>  // Required for strncat\n#include <iostream> // Required for std::cout\n\nint main() {\n    char destination[50] = \"Hello, \";\n    const char* source = \"World!\";\n    \n    // Calculate the remaining space in the destination buffer\n    size_t remaining_space = sizeof(destination) - strlen(destination) - 1;\n\n    // Use strncat to safely concatenate strings\n    strncat(destination, source, remaining_space);\n\n    std::cout << destination << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncat`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS141863"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-6aa88551-d401-4604-9f33-1a10ebb2d9e4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2143,
                  "startColumn": 30,
                  "endLine": 2143,
                  "endColumn": 38,
                  "charOffset": 78616,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-78db7ee9-6466-4368-bad2-f0c5e9d6aa5c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2157,
                  "startColumn": 30,
                  "endLine": 2157,
                  "endColumn": 35,
                  "charOffset": 79079,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3a112cca-49e8-4772-ae5b-92c963936cb8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2143,
                  "startColumn": 30,
                  "endLine": 2143,
                  "endColumn": 35,
                  "charOffset": 78616,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-cb4be66d-6cc9-4ad6-9840-a0642db3fbe3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2086,
                  "startColumn": 30,
                  "endLine": 2086,
                  "endColumn": 35,
                  "charOffset": 76951,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-203f96fe-9874-4fa7-ba14-9379f03d8936",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2086,
                  "startColumn": 30,
                  "endLine": 2086,
                  "endColumn": 38,
                  "charOffset": 76951,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-16e97856-c9f6-425f-8758-bcc1cff0f18b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2071,
                  "startColumn": 30,
                  "endLine": 2071,
                  "endColumn": 35,
                  "charOffset": 76453,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-5757c872-d0fd-49e0-a4b9-1fe4f644c6b1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 2071,
                  "startColumn": 30,
                  "endLine": 2071,
                  "endColumn": 38,
                  "charOffset": 76453,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7eb6e80f-0617-4003-b4bd-2229cef8882b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1962,
                  "startColumn": 41,
                  "endLine": 1962,
                  "endColumn": 49,
                  "charOffset": 72546,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-493c0581-260a-4db2-b9fb-df4e807953f4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1962,
                  "startColumn": 31,
                  "endLine": 1962,
                  "endColumn": 36,
                  "charOffset": 72536,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e128afe0-82a3-4c83-aa99-dae04d933188",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1879,
                  "startColumn": 8,
                  "endLine": 1879,
                  "endColumn": 65,
                  "charOffset": 69465,
                  "charLength": 57,
                  "snippet": {
                    "text": "strncat((char*)page_alnd_addr, (char*)needle, needle_len)",
                    "rendered": {
                      "text": "strncat((char*)page_alnd_addr, (char*)needle, needle_len)",
                      "markdown": "`strncat((char*)page_alnd_addr, (char*)needle, needle_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69465,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "strcat_s((char*)page_alnd_addr,  needle_len,  (char*)needle)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69465,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "strlcat((char*)page_alnd_addr,  (char*)needle,  needle_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b547d5c1-36ff-4139-908e-0f2ed21e438d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1750,
                  "startColumn": 14,
                  "endLine": 1750,
                  "endColumn": 75,
                  "charOffset": 64335,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)",
                    "rendered": {
                      "text": "strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)",
                      "markdown": "`strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64335,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr,  size,  (char *)str3_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64335,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *)str3_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-de831fc6-a77f-49e3-a765-012b34bba68e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1746,
                  "startColumn": 24,
                  "endLine": 1746,
                  "endColumn": 29,
                  "charOffset": 64118,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-cdbfdf65-03b7-49cf-9df0-d65505bd9c74",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1746,
                  "startColumn": 24,
                  "endLine": 1746,
                  "endColumn": 32,
                  "charOffset": 64118,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-127807b1-d562-4826-a428-f4e1c9f89acb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1733,
                  "startColumn": 14,
                  "endLine": 1733,
                  "endColumn": 75,
                  "charOffset": 63481,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)",
                    "rendered": {
                      "text": "strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)",
                      "markdown": "`strncat((char *)str1_alnd_addr, (char *)str3_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63481,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr,  size,  (char *)str3_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63481,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *)str3_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8dbc49a8-9309-438c-9ef0-a4de2237531c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1728,
                  "startColumn": 24,
                  "endLine": 1728,
                  "endColumn": 29,
                  "charOffset": 63230,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c55e29d4-1635-457b-a948-1f174bdb7fc7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1728,
                  "startColumn": 24,
                  "endLine": 1728,
                  "endColumn": 31,
                  "charOffset": 63230,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-2ac7b43d-a491-406e-87cd-42b166e9e47b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1696,
                  "startColumn": 10,
                  "endLine": 1696,
                  "endColumn": 71,
                  "charOffset": 62051,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)",
                    "rendered": {
                      "text": "strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)",
                      "markdown": "`strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62051,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr,  size,  (char *)str2_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62051,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *)str2_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-752e1b57-e685-4659-8f01-edccec3cc901",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1691,
                  "startColumn": 27,
                  "endLine": 1691,
                  "endColumn": 32,
                  "charOffset": 61848,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-000a774b-7a62-496a-8c8c-a2726e6ed77c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1691,
                  "startColumn": 27,
                  "endLine": 1691,
                  "endColumn": 35,
                  "charOffset": 61848,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1536240b-aae2-477f-85b2-2204136f002d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1663,
                  "startColumn": 24,
                  "endLine": 1663,
                  "endColumn": 32,
                  "charOffset": 60804,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-02d9d9ba-df43-4c05-a9ac-abcd7bd60506",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1678,
                  "startColumn": 10,
                  "endLine": 1678,
                  "endColumn": 71,
                  "charOffset": 61260,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)",
                    "rendered": {
                      "text": "strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)",
                      "markdown": "`strncat((char *)str1_alnd_addr, (char *)str2_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61260,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr,  size,  (char *)str2_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61260,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *)str2_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b6d4205a-2314-4ca4-bfe0-4c655c9b1daa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1663,
                  "startColumn": 24,
                  "endLine": 1663,
                  "endColumn": 29,
                  "charOffset": 60804,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d2476d55-6316-4beb-8529-6e4d2b3cb6cf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1609,
                  "startColumn": 14,
                  "endLine": 1609,
                  "endColumn": 53,
                  "charOffset": 58829,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcat((char *)str1_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcat((char *)str1_alnd_addr, (char *)",
                      "markdown": "`strcat((char *)str1_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58829,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr, <size of (char *)str1_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58829,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *, <size of (char *)str1_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c5e2b8a-683f-4cbd-991c-00dafdfa0f3a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1604,
                  "startColumn": 24,
                  "endLine": 1604,
                  "endColumn": 29,
                  "charOffset": 58612,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3a36f036-aaec-4c09-b259-ceeeaa450d2d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1604,
                  "startColumn": 24,
                  "endLine": 1604,
                  "endColumn": 32,
                  "charOffset": 58612,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e252d2a3-4472-47f2-943b-3182f2dea273",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1591,
                  "startColumn": 14,
                  "endLine": 1591,
                  "endColumn": 53,
                  "charOffset": 58000,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcat((char *)str1_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcat((char *)str1_alnd_addr, (char *)",
                      "markdown": "`strcat((char *)str1_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58000,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr, <size of (char *)str1_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58000,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *, <size of (char *)str1_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6bf82bfb-bba3-4ed0-802a-21f6d5bda9f5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1588,
                  "startColumn": 58,
                  "endLine": 1588,
                  "endColumn": 63,
                  "charOffset": 57885,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-807876b3-270b-47d0-bd5b-7d545515864f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1586,
                  "startColumn": 53,
                  "endLine": 1586,
                  "endColumn": 58,
                  "charOffset": 57794,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-09e49a80-318c-4fdc-a629-2874099f7c92",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1588,
                  "startColumn": 58,
                  "endLine": 1588,
                  "endColumn": 65,
                  "charOffset": 57885,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-bfa7a197-bf32-4bf0-86cd-2430dea179b5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1586,
                  "startColumn": 53,
                  "endLine": 1586,
                  "endColumn": 61,
                  "charOffset": 57794,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0f80f074-671b-46ce-8ec4-ba8d166aa4d4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1585,
                  "startColumn": 53,
                  "endLine": 1585,
                  "endColumn": 58,
                  "charOffset": 57718,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d45204f9-1b65-44c0-aa51-e7475ac89b1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1585,
                  "startColumn": 53,
                  "endLine": 1585,
                  "endColumn": 61,
                  "charOffset": 57718,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-a0f579e9-cd2f-4c46-8e6e-4d1ab20f5751",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1552,
                  "startColumn": 10,
                  "endLine": 1552,
                  "endColumn": 49,
                  "charOffset": 56451,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcat((char *)str1_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcat((char *)str1_alnd_addr, (char *)",
                      "markdown": "`strcat((char *)str1_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56451,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr, <size of (char *)str1_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56451,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *, <size of (char *)str1_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a313c37c-b98c-433d-a268-b004a327b716",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1547,
                  "startColumn": 27,
                  "endLine": 1547,
                  "endColumn": 35,
                  "charOffset": 56248,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b26e54d7-c5e1-4439-abe3-663b09d2dbdd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1547,
                  "startColumn": 27,
                  "endLine": 1547,
                  "endColumn": 32,
                  "charOffset": 56248,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-4e25b2dd-d033-4856-8ddd-2864e8906364",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1535,
                  "startColumn": 10,
                  "endLine": 1535,
                  "endColumn": 49,
                  "charOffset": 55685,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcat((char *)str1_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcat((char *)str1_alnd_addr, (char *)",
                      "markdown": "`strcat((char *)str1_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55685,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcat_s((char *)str1_alnd_addr, <size of (char *)str1_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55685,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcat((char *)str1_alnd_addr,  (char *, <size of (char *)str1_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c9ae943b-4477-4442-80f3-3be9fe51f17b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1520,
                  "startColumn": 24,
                  "endLine": 1520,
                  "endColumn": 29,
                  "charOffset": 55236,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7d3246cf-3498-4197-8373-1d36824f4913",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1520,
                  "startColumn": 24,
                  "endLine": 1520,
                  "endColumn": 31,
                  "charOffset": 55236,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0d4de2ca-8b08-469e-a003-8733f9321185",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1516,
                  "startColumn": 49,
                  "endLine": 1516,
                  "endColumn": 54,
                  "charOffset": 55074,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-098a2509-64af-4bff-a96e-9c3b55a8b9fa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1515,
                  "startColumn": 49,
                  "endLine": 1515,
                  "endColumn": 54,
                  "charOffset": 55002,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-2f71e7bb-e207-42d2-821a-f4d2fd4eb8df",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1516,
                  "startColumn": 49,
                  "endLine": 1516,
                  "endColumn": 57,
                  "charOffset": 55074,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7b63ad1a-05bd-4266-b0fe-d0e706ffc9a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1515,
                  "startColumn": 49,
                  "endLine": 1515,
                  "endColumn": 57,
                  "charOffset": 55002,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e811a1fe-95f4-46d7-87ea-4787292ff9c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1406,
                  "startColumn": 10,
                  "endLine": 1406,
                  "endColumn": 25,
                  "charOffset": 51468,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen((char *)",
                    "rendered": {
                      "text": "strlen((char *)",
                      "markdown": "`strlen((char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51468,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s((char *, <size of (char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51468,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen((char *, <size of (char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6618f7b-c608-4070-80c3-0dcdaee34e1a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1402,
                  "startColumn": 48,
                  "endLine": 1402,
                  "endColumn": 53,
                  "charOffset": 51383,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f49f8302-0067-40db-9d08-144371f57a02",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1402,
                  "startColumn": 48,
                  "endLine": 1402,
                  "endColumn": 56,
                  "charOffset": 51383,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-16a63ca8-b1be-4ad7-8935-69b91608ca55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1374,
                  "startColumn": 10,
                  "endLine": 1374,
                  "endColumn": 25,
                  "charOffset": 50593,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen((char *)",
                    "rendered": {
                      "text": "strlen((char *)",
                      "markdown": "`strlen((char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50593,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s((char *, <size of (char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50593,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen((char *, <size of (char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cacb2cf9-85f1-4108-99fa-fa90c5eb38fe",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1373,
                  "startColumn": 29,
                  "endLine": 1373,
                  "endColumn": 34,
                  "charOffset": 50552,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-a1eaaf9f-cf5f-4b75-b4c9-1a8ea50d892b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1373,
                  "startColumn": 29,
                  "endLine": 1373,
                  "endColumn": 37,
                  "charOffset": 50552,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-813bdc26-4ef8-408d-89ef-2f6deb6bb89f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1367,
                  "startColumn": 49,
                  "endLine": 1367,
                  "endColumn": 57,
                  "charOffset": 50351,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-59b7e0ea-1b67-48a4-8f98-b9b9cdf0bd74",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1367,
                  "startColumn": 49,
                  "endLine": 1367,
                  "endColumn": 54,
                  "charOffset": 50351,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d99b82dc-8e43-4a59-b67d-cb36496e05ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1334,
                  "startColumn": 35,
                  "endLine": 1334,
                  "endColumn": 47,
                  "charOffset": 49228,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49228,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49228,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-708b8d3c-e125-4091-9a1b-cf2b62aae6c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1334,
                  "startColumn": 20,
                  "endLine": 1334,
                  "endColumn": 32,
                  "charOffset": 49213,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49213,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49213,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1eca9e53-577d-4502-83e0-e223a5ea1935",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1320,
                  "startColumn": 23,
                  "endLine": 1320,
                  "endColumn": 31,
                  "charOffset": 48548,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e65754c8-b351-4110-adbc-7cbc13b8f9a2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1320,
                  "startColumn": 57,
                  "endLine": 1320,
                  "endColumn": 69,
                  "charOffset": 48582,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48582,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48582,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-32ce2496-6514-4d33-94b4-0c3de1fc9c95",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1320,
                  "startColumn": 23,
                  "endLine": 1320,
                  "endColumn": 28,
                  "charOffset": 48548,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-945dd2c1-ae5a-43df-a73d-bbf5de66ab2b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 47,
                  "endLine": 1319,
                  "endColumn": 59,
                  "charOffset": 48489,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48489,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48489,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4dbc3cb-7a1f-4e64-ac52-6eb00acf16a8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 23,
                  "endLine": 1319,
                  "endColumn": 28,
                  "charOffset": 48465,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-24bfd7ef-6ad3-4b61-b51d-9532a8432488",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 23,
                  "endLine": 1319,
                  "endColumn": 31,
                  "charOffset": 48465,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8462d550-8837-45a9-b33a-37347022c874",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1317,
                  "startColumn": 35,
                  "endLine": 1317,
                  "endColumn": 47,
                  "charOffset": 48334,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48334,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48334,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cbcc1f26-e712-45ee-9a3f-d008508c53ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1317,
                  "startColumn": 20,
                  "endLine": 1317,
                  "endColumn": 32,
                  "charOffset": 48319,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48319,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48319,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bbcb6730-6f67-4c4b-b57b-8c35899b2457",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1314,
                  "startColumn": 13,
                  "endLine": 1314,
                  "endColumn": 25,
                  "charOffset": 48240,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48240,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48240,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7e54843-22a7-422a-b5f4-e39a8763bf79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1311,
                  "startColumn": 60,
                  "endLine": 1311,
                  "endColumn": 74,
                  "charOffset": 48145,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48145,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48145,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3f1e118c-d483-4619-a33a-df466f866958",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1302,
                  "startColumn": 36,
                  "endLine": 1302,
                  "endColumn": 48,
                  "charOffset": 47704,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47704,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47704,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dfe3a0e5-400e-445a-9aef-86d8c57a7ca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1302,
                  "startColumn": 12,
                  "endLine": 1302,
                  "endColumn": 24,
                  "charOffset": 47680,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47680,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47680,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a1867ff-aa23-4840-80da-d585c49d02ba",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1299,
                  "startColumn": 60,
                  "endLine": 1299,
                  "endColumn": 74,
                  "charOffset": 47586,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47586,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47586,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3b469947-329d-40ae-b676-32d13a534ae0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1290,
                  "startColumn": 37,
                  "endLine": 1290,
                  "endColumn": 49,
                  "charOffset": 47095,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47095,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47095,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5e93d54d-cfb5-4002-b8d3-69dedd18506a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1290,
                  "startColumn": 13,
                  "endLine": 1290,
                  "endColumn": 25,
                  "charOffset": 47071,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47071,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47071,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0815c78b-a1a4-4d1b-ab40-7ba9d727c244",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1287,
                  "startColumn": 95,
                  "endLine": 1287,
                  "endColumn": 109,
                  "charOffset": 46975,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46975,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46975,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9263db72-5961-48ec-bb76-c92ea1d5ad83",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1287,
                  "startColumn": 65,
                  "endLine": 1287,
                  "endColumn": 79,
                  "charOffset": 46945,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46945,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46945,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bb1bd29f-6b81-416d-962d-7bb3e8148ba9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1278,
                  "startColumn": 77,
                  "endLine": 1278,
                  "endColumn": 85,
                  "charOffset": 46553,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1c04e29a-396f-4b31-93bc-30dc8040b4c8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1278,
                  "startColumn": 77,
                  "endLine": 1278,
                  "endColumn": 82,
                  "charOffset": 46553,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-252d9842-78ae-4eda-a7f4-38a7fbe71a13",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1274,
                  "startColumn": 27,
                  "endLine": 1274,
                  "endColumn": 39,
                  "charOffset": 46389,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46389,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46389,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-416fdb34-3d3d-47c7-9933-92e7b4e5663f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1274,
                  "startColumn": 13,
                  "endLine": 1274,
                  "endColumn": 25,
                  "charOffset": 46375,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46375,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46375,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-79216bf9-be48-485c-81b3-15698c38eab8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1254,
                  "startColumn": 31,
                  "endLine": 1254,
                  "endColumn": 39,
                  "charOffset": 45531,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-40697189-ae7f-47b7-bc16-51634f151e8c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1254,
                  "startColumn": 31,
                  "endLine": 1254,
                  "endColumn": 36,
                  "charOffset": 45531,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-dbf2ad9e-ca17-407a-b924-9057cee76f10",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1199,
                  "startColumn": 78,
                  "endLine": 1199,
                  "endColumn": 86,
                  "charOffset": 43124,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-01abcc3f-efc1-4ff7-8569-31775e074c44",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1199,
                  "startColumn": 78,
                  "endLine": 1199,
                  "endColumn": 83,
                  "charOffset": 43124,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e1ff085d-38af-4740-b7f9-0dc34476507b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1152,
                  "startColumn": 76,
                  "endLine": 1152,
                  "endColumn": 81,
                  "charOffset": 41569,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-76110344-70bd-4855-aa62-8b7d7db68774",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1152,
                  "startColumn": 76,
                  "endLine": 1152,
                  "endColumn": 84,
                  "charOffset": 41569,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-fe4501b9-e7c7-4326-9eb1-2068e6f26685",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1124,
                  "startColumn": 35,
                  "endLine": 1124,
                  "endColumn": 47,
                  "charOffset": 40584,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40584,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40584,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f40b19d9-5946-4fd7-adec-d6b9b5576622",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1124,
                  "startColumn": 20,
                  "endLine": 1124,
                  "endColumn": 32,
                  "charOffset": 40569,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40569,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40569,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8007dd79-edb0-4dd8-a04d-63034fb6b829",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1110,
                  "startColumn": 57,
                  "endLine": 1110,
                  "endColumn": 69,
                  "charOffset": 39946,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39946,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39946,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6fa5d2d3-c9ec-4cba-aa08-70099ebf7ab5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1110,
                  "startColumn": 23,
                  "endLine": 1110,
                  "endColumn": 28,
                  "charOffset": 39912,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ddf8be51-d3d3-42d4-8b36-a96f71921d7c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1110,
                  "startColumn": 23,
                  "endLine": 1110,
                  "endColumn": 31,
                  "charOffset": 39912,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e5197feb-17fa-45cf-9e00-b21e36707431",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1109,
                  "startColumn": 47,
                  "endLine": 1109,
                  "endColumn": 59,
                  "charOffset": 39853,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39853,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39853,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-50e30333-ca97-4ab5-9570-9029f309aff4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1109,
                  "startColumn": 23,
                  "endLine": 1109,
                  "endColumn": 31,
                  "charOffset": 39829,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-68ef2bfc-d8ac-438e-bee3-0600e1db08d5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1109,
                  "startColumn": 23,
                  "endLine": 1109,
                  "endColumn": 28,
                  "charOffset": 39829,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-82d7f5da-1ef1-4c95-8cfc-d74ed8de0f14",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1107,
                  "startColumn": 35,
                  "endLine": 1107,
                  "endColumn": 47,
                  "charOffset": 39698,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39698,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39698,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-16852f02-8659-4ebf-848e-cfdf9a0f0eb8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1107,
                  "startColumn": 20,
                  "endLine": 1107,
                  "endColumn": 32,
                  "charOffset": 39683,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39683,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39683,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-062931e7-798e-4b57-a436-61e41fb5de83",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1104,
                  "startColumn": 13,
                  "endLine": 1104,
                  "endColumn": 25,
                  "charOffset": 39604,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39604,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39604,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b9ce516d-5b5a-465d-8724-e1393a89c793",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1101,
                  "startColumn": 59,
                  "endLine": 1101,
                  "endColumn": 73,
                  "charOffset": 39509,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39509,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39509,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88dcc73c-5af0-410d-8b01-08a742c9a2d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1092,
                  "startColumn": 36,
                  "endLine": 1092,
                  "endColumn": 48,
                  "charOffset": 39078,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39078,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39078,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8efdfe50-275c-45b6-99b1-54027ed5330c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1092,
                  "startColumn": 12,
                  "endLine": 1092,
                  "endColumn": 24,
                  "charOffset": 39054,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39054,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39054,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-03b5e81f-7061-4f8b-95a7-c4ce8cc0b5cf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1089,
                  "startColumn": 59,
                  "endLine": 1089,
                  "endColumn": 73,
                  "charOffset": 38960,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38960,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38960,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-947ed0e9-7e6f-4552-a5e8-0b32a315dea0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1080,
                  "startColumn": 37,
                  "endLine": 1080,
                  "endColumn": 49,
                  "charOffset": 38479,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38479,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38479,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-84d98822-45f7-4a0a-a622-8fd5ed8bad9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1077,
                  "startColumn": 95,
                  "endLine": 1077,
                  "endColumn": 109,
                  "charOffset": 38359,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38359,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38359,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cde5ee48-1327-4937-b598-5267838110ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1080,
                  "startColumn": 13,
                  "endLine": 1080,
                  "endColumn": 25,
                  "charOffset": 38455,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38455,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38455,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-31a1d370-2ca6-4235-9a17-1c6ab46a5f29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1077,
                  "startColumn": 65,
                  "endLine": 1077,
                  "endColumn": 79,
                  "charOffset": 38329,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen((char*)",
                    "rendered": {
                      "text": "strlen((char*)",
                      "markdown": "`strlen((char*)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38329,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38329,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen((char*, <size of (char*>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea667f2d-eadf-496e-84c6-4011bdc962f7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1068,
                  "startColumn": 77,
                  "endLine": 1068,
                  "endColumn": 82,
                  "charOffset": 37948,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0712455c-5966-4033-aa34-e98b08508adc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1064,
                  "startColumn": 27,
                  "endLine": 1064,
                  "endColumn": 39,
                  "charOffset": 37784,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str2)",
                    "rendered": {
                      "text": "strlen(str2)",
                      "markdown": "`strlen(str2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37784,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37784,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str2, <size of str2>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d1805eeb-a035-4380-a615-d057c0498b6f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1068,
                  "startColumn": 77,
                  "endLine": 1068,
                  "endColumn": 85,
                  "charOffset": 37948,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-53158b4d-1c61-4135-a125-dcc78a337a36",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1064,
                  "startColumn": 13,
                  "endLine": 1064,
                  "endColumn": 25,
                  "charOffset": 37770,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(str1)",
                    "rendered": {
                      "text": "strlen(str1)",
                      "markdown": "`strlen(str1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37770,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37770,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(str1, <size of str1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c83d0499-599c-4b7b-84f4-df68a3a3c96c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1044,
                  "startColumn": 31,
                  "endLine": 1044,
                  "endColumn": 36,
                  "charOffset": 36935,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-baf6fa9f-b283-4cd2-9582-e88a3aa79e3e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 1044,
                  "startColumn": 31,
                  "endLine": 1044,
                  "endColumn": 39,
                  "charOffset": 36935,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-33307925-3b63-40ca-bb71-78509f9e3636",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 990,
                  "startColumn": 78,
                  "endLine": 990,
                  "endColumn": 86,
                  "charOffset": 34585,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-deacd0d6-446c-4b6a-b77f-174075990e73",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 990,
                  "startColumn": 78,
                  "endLine": 990,
                  "endColumn": 83,
                  "charOffset": 34585,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f69aaf66-3fac-4c65-a1b6-2e04314d9f1c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 922,
                  "startColumn": 10,
                  "endLine": 922,
                  "endColumn": 71,
                  "charOffset": 31908,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                    "rendered": {
                      "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                      "markdown": "`strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31908,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr,  size,  (char *)str1_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31908,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *)str1_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0a9ed056-5e98-4b32-9902-1d4c242b7c89",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 913,
                  "startColumn": 27,
                  "endLine": 913,
                  "endColumn": 35,
                  "charOffset": 31682,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9815a51d-1d13-4db5-b071-58cbd7b8f586",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 913,
                  "startColumn": 27,
                  "endLine": 913,
                  "endColumn": 32,
                  "charOffset": 31682,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-618c1081-6e3f-4ed5-bce6-6e7c9c8f86ef",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 912,
                  "startColumn": 22,
                  "endLine": 912,
                  "endColumn": 30,
                  "charOffset": 31638,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-154bce13-0965-4330-8ce2-5d5b61ca420c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 912,
                  "startColumn": 22,
                  "endLine": 912,
                  "endColumn": 27,
                  "charOffset": 31638,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-df509bf1-8100-4c95-aecc-f27ad4c522d1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 886,
                  "startColumn": 10,
                  "endLine": 886,
                  "endColumn": 71,
                  "charOffset": 30353,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                    "rendered": {
                      "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                      "markdown": "`strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30353,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr,  size,  (char *)str1_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30353,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *)str1_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-afb43118-9ec8-4055-9c84-5277f9f215f3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 859,
                  "startColumn": 10,
                  "endLine": 859,
                  "endColumn": 71,
                  "charOffset": 29029,
                  "charLength": 61,
                  "snippet": {
                    "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                    "rendered": {
                      "text": "strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)",
                      "markdown": "`strncpy((char *)str2_alnd_addr, (char *)str1_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29029,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr,  size,  (char *)str1_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29029,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *)str1_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d02aaa0d-86e3-45a9-9f7b-3ce70ec1f0cd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 853,
                  "startColumn": 49,
                  "endLine": 853,
                  "endColumn": 57,
                  "charOffset": 28817,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-502210a8-5067-4c4c-a5dd-2dc109b5756f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 853,
                  "startColumn": 49,
                  "endLine": 853,
                  "endColumn": 54,
                  "charOffset": 28817,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-2076439b-5c52-48d7-8f03-3eb4ad31f48f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 832,
                  "startColumn": 14,
                  "endLine": 832,
                  "endColumn": 73,
                  "charOffset": 28129,
                  "charLength": 59,
                  "snippet": {
                    "text": "strncpy((char*)str2_alnd_addr, (char*)str1_alnd_addr, size)",
                    "rendered": {
                      "text": "strncpy((char*)str2_alnd_addr, (char*)str1_alnd_addr, size)",
                      "markdown": "`strncpy((char*)str2_alnd_addr, (char*)str1_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28129,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char*)str2_alnd_addr,  size,  (char*)str1_alnd_addr)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28129,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strlcpy((char*)str2_alnd_addr,  (char*)str1_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c4a22317-1485-44f5-b58b-48c1700b50e4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 802,
                  "startColumn": 10,
                  "endLine": 802,
                  "endColumn": 49,
                  "charOffset": 26889,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy((char *)str2_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcpy((char *)str2_alnd_addr, (char *)",
                      "markdown": "`strcpy((char *)str2_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26889,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr, <size of (char *)str2_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26889,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *, <size of (char *)str2_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fbdbd077-7dc9-452f-aae1-9fde4cf6814a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 798,
                  "startColumn": 49,
                  "endLine": 798,
                  "endColumn": 54,
                  "charOffset": 26800,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8efe9829-7fe1-4817-9735-477189ca59b3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 798,
                  "startColumn": 49,
                  "endLine": 798,
                  "endColumn": 57,
                  "charOffset": 26800,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c6a9df7c-3bfe-4568-a9a6-6bf3a8d71ea4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 763,
                  "startColumn": 10,
                  "endLine": 763,
                  "endColumn": 49,
                  "charOffset": 25332,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy((char *)str2_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcpy((char *)str2_alnd_addr, (char *)",
                      "markdown": "`strcpy((char *)str2_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25332,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr, <size of (char *)str2_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25332,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *, <size of (char *)str2_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-764d89f8-fa96-4ad8-b60d-7643b26e5f2b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 760,
                  "startColumn": 27,
                  "endLine": 760,
                  "endColumn": 35,
                  "charOffset": 25248,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c4ade2ca-8ae5-444e-b937-9082b5896987",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 760,
                  "startColumn": 27,
                  "endLine": 760,
                  "endColumn": 32,
                  "charOffset": 25248,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e4127223-bc6f-4999-be4e-fe4944792eb4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 742,
                  "startColumn": 10,
                  "endLine": 742,
                  "endColumn": 49,
                  "charOffset": 24401,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy((char *)str2_alnd_addr, (char *)",
                    "rendered": {
                      "text": "strcpy((char *)str2_alnd_addr, (char *)",
                      "markdown": "`strcpy((char *)str2_alnd_addr, (char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24401,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s((char *)str2_alnd_addr, <size of (char *)str2_alnd_addr>,  (char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24401,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy((char *)str2_alnd_addr,  (char *, <size of (char *)str2_alnd_addr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0a1b37ad-36b0-4e13-8b3e-dd0d4c42dfab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 738,
                  "startColumn": 49,
                  "endLine": 738,
                  "endColumn": 57,
                  "charOffset": 24253,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b66b0dae-ee9b-42af-8983-9563d5344fde",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 738,
                  "startColumn": 49,
                  "endLine": 738,
                  "endColumn": 54,
                  "charOffset": 24253,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-36d86c33-b50c-454a-b84b-e462f24d71e3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 688,
                  "startColumn": 46,
                  "endLine": 688,
                  "endColumn": 51,
                  "charOffset": 22551,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8b1a6d53-248a-4c2b-9747-d0620dd1e6a6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 70,
                  "endLine": 669,
                  "endColumn": 75,
                  "charOffset": 21915,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-733794d7-6002-432d-a368-c18ad6fe8d9d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 70,
                  "endLine": 669,
                  "endColumn": 77,
                  "charOffset": 21915,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-baed24e2-3821-49f8-b0ed-35836575d629",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 613,
                  "startColumn": 12,
                  "endLine": 613,
                  "endColumn": 19,
                  "charOffset": 19967,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-5c319af9-9218-4bc9-8cd8-7f76878e69ad",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 613,
                  "startColumn": 12,
                  "endLine": 613,
                  "endColumn": 17,
                  "charOffset": 19967,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-96522093-cdae-48c6-8acb-2fc9aeda8a1e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 40,
                  "endLine": 558,
                  "endColumn": 45,
                  "charOffset": 17945,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e86d5537-f1a8-4b97-9b02-8f72e7f7bc0b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 40,
                  "endLine": 558,
                  "endColumn": 47,
                  "charOffset": 17945,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-db2a717b-8552-49d1-a302-f4fa19c37321",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 70,
                  "endLine": 522,
                  "endColumn": 75,
                  "charOffset": 16572,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-96322584-3e44-4c69-bc22-bd9e62978956",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 70,
                  "endLine": 522,
                  "endColumn": 77,
                  "charOffset": 16572,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8485d2f2-dae4-41bf-b362-7f13211c2ee5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 498,
                  "startColumn": 70,
                  "endLine": 498,
                  "endColumn": 75,
                  "charOffset": 15482,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-bca4736b-208e-48f0-b9b5-700c73a92c56",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 498,
                  "startColumn": 70,
                  "endLine": 498,
                  "endColumn": 77,
                  "charOffset": 15482,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-bd237c7d-bd80-4454-9bef-fc8ea366f735",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 429,
                  "startColumn": 40,
                  "endLine": 429,
                  "endColumn": 45,
                  "charOffset": 13119,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-08dd842b-fd1c-4b26-9f31-54c4d4808295",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 429,
                  "startColumn": 40,
                  "endLine": 429,
                  "endColumn": 47,
                  "charOffset": 13119,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-5ef170a7-2b53-4440-bc75-6d80a64b0344",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 371,
                  "startColumn": 10,
                  "endLine": 371,
                  "endColumn": 52,
                  "charOffset": 11100,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(dst_alnd_addr, src_alnd_addr, size)",
                    "rendered": {
                      "text": "memcpy(dst_alnd_addr, src_alnd_addr, size)",
                      "markdown": "`memcpy(dst_alnd_addr, src_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11100,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_alnd_addr, <size of dst_alnd_addr>,  src_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8b2f6416-2cd8-491d-8752-e47a2de22287",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 370,
                  "startColumn": 40,
                  "endLine": 370,
                  "endColumn": 45,
                  "charOffset": 11070,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-64a80e19-1415-40f8-9d36-48be44f72d16",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 370,
                  "startColumn": 40,
                  "endLine": 370,
                  "endColumn": 47,
                  "charOffset": 11070,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1f367c46-ab6f-49ba-9f8e-1542223d0cce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 14,
                  "endLine": 349,
                  "endColumn": 56,
                  "charOffset": 10394,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(dst_alnd_addr, src_alnd_addr, size)",
                    "rendered": {
                      "text": "memcpy(dst_alnd_addr, src_alnd_addr, size)",
                      "markdown": "`memcpy(dst_alnd_addr, src_alnd_addr, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10394,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_alnd_addr, <size of dst_alnd_addr>,  src_alnd_addr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba4e961b-f2a3-44eb-8f01-e9066ba40279",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 16,
                  "endLine": 332,
                  "endColumn": 23,
                  "charOffset": 9914,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ac29bc0f-e7a2-4ba2-bf4a-051f199265b9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 16,
                  "endLine": 332,
                  "endColumn": 21,
                  "charOffset": 9914,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1c67813c-1f9d-4a68-a7bc-37bcfdb938c8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 16,
                  "endLine": 331,
                  "endColumn": 21,
                  "charOffset": 9869,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ce63cb04-a66f-40bd-86d5-28afe43cf881",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 16,
                  "endLine": 331,
                  "endColumn": 23,
                  "charOffset": 9869,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b4c03f0d-1d33-421f-93da-12ad7d037b6c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 16,
                  "endLine": 329,
                  "endColumn": 21,
                  "charOffset": 9806,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d7d5ac76-1a7b-4fdc-bcad-b89caa8c5a34",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 16,
                  "endLine": 329,
                  "endColumn": 23,
                  "charOffset": 9806,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-cf1501a6-2035-4347-880b-18e8e47334a4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 12,
                  "endLine": 324,
                  "endColumn": 19,
                  "charOffset": 9695,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3fd5495f-8520-4d64-a564-8b8d4b401a77",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 12,
                  "endLine": 324,
                  "endColumn": 17,
                  "charOffset": 9695,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d70ecc50-0473-4338-96c3-b031644505eb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 35,
                  "endLine": 321,
                  "endColumn": 40,
                  "charOffset": 9559,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-29619e8d-ea63-4414-955c-bdf667a2e9a7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 35,
                  "endLine": 321,
                  "endColumn": 43,
                  "charOffset": 9559,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-232a4b03-9c22-447b-ad5c-a564ee8775b2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 20,
                  "endLine": 310,
                  "endColumn": 28,
                  "charOffset": 9281,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0a2cae6a-cb32-43ca-98d6-292fc851a984",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 20,
                  "endLine": 310,
                  "endColumn": 25,
                  "charOffset": 9281,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c92faa20-fc1f-43ec-8cb5-ed575b5feada",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 8,
                  "endLine": 304,
                  "endColumn": 36,
                  "charOffset": 9094,
                  "charLength": 28,
                  "snippet": {
                    "text": "strncat(haystack, needle, i)",
                    "rendered": {
                      "text": "strncat(haystack, needle, i)",
                      "markdown": "`strncat(haystack, needle, i)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9094,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(haystack,  i,  needle)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "tools/validator/libmem_validator.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9094,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(haystack,  needle,  i)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba9e4300-a6da-4ecf-9b30-045037bb8ee3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 17,
                  "endLine": 295,
                  "endColumn": 25,
                  "charOffset": 8839,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-85db9601-1e71-4900-b9cf-ee5b264190b9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 17,
                  "endLine": 295,
                  "endColumn": 22,
                  "charOffset": 8839,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-cd81430b-cd9d-4e10-a12a-c5cb998343cb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 40,
                  "endLine": 284,
                  "endColumn": 45,
                  "charOffset": 8634,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0e29f830-0871-4bab-9382-bdadaf526e34",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 40,
                  "endLine": 284,
                  "endColumn": 48,
                  "charOffset": 8634,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1eb02f89-ca3a-4ecb-b0d8-4dab083449e5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 29,
                  "endLine": 216,
                  "endColumn": 36,
                  "charOffset": 6482,
                  "charLength": 7,
                  "snippet": {
                    "text": "rand()%",
                    "rendered": {
                      "text": "rand()%",
                      "markdown": "`rand()%`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e2894065-1de1-4a33-b7d0-27de503d3f38",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "tools/validator/libmem_validator.c"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 29,
                  "endLine": 216,
                  "endColumn": 34,
                  "charOffset": 6482,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-30aa39b1-d4e3-4027-9737-45e4aa7f17c1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/memcpy_zen2.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 42,
                  "charOffset": 1793,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/memcpy_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1793,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8f9c3534-6aa7-4541-908d-db03854bf7b6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/strncpy_zen2.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 43,
                  "charOffset": 1822,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strncpy_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strncpy_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b8887eb6-63db-4408-9e3e-71e8a9a13b96",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/strncat_zen5.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 43,
                  "charOffset": 1819,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strncat_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1819,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strncat_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1819,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-abb6ef0c-3eff-477b-8c0e-967783410b45",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/memcpy_zen5.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 42,
                  "charOffset": 1812,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/memcpy_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1812,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-90ef4c0e-2464-4405-994a-d243c1e347fd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/strncpy_zen5.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 43,
                  "charOffset": 1828,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strncpy_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1828,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strncpy_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1828,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a2b4ebae-9f4f-47c7-8ea3-a119ed8d417b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/strcpy_zen5.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 34,
                  "charOffset": 1806,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strcpy_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1806,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strcpy_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1806,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5a8f1746-d6f0-463f-944e-d5be10bbcf9a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/strcat_zen5.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 34,
                  "charOffset": 1803,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strcat_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1803,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strcat_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1803,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5317d534-3d15-4baa-8e49-9103bbce410c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen5/strlen_zen5.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 7,
                  "endLine": 32,
                  "endColumn": 27,
                  "charOffset": 1788,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strlen_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen5/strlen_zen5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58bb0a7d-c839-43fe-b6b7-40c39ad5acd3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/strncpy_zen1.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 43,
                  "charOffset": 1822,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strncpy_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strncpy_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-523b8c53-105d-4e72-a739-b43fc60bf43f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/strcpy_zen1.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 34,
                  "charOffset": 1800,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strcpy_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strcpy_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-54669c5c-2e2c-456f-8e20-4ef60fe88463",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/memcpy_zen1.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 42,
                  "charOffset": 1793,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/memcpy_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1793,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f672b1c1-096b-4507-9f12-0ee4950ebcb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/strncat_zen1.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 43,
                  "charOffset": 1813,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strncat_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strncat_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bba086ac-983c-40f8-b225-8f128f514b8b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/strlen_zen1.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 7,
                  "endLine": 32,
                  "endColumn": 27,
                  "charOffset": 1782,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strlen_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strlen_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8d0c5827-0095-4f43-83a6-ef5955182198",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen1/strcat_zen1.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 34,
                  "charOffset": 1797,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strcat_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen1/strcat_zen1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9640b4e1-bc0f-4089-9ce5-98224b4c19e6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx2/strlen_avx2.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 7,
                  "endLine": 31,
                  "endColumn": 27,
                  "charOffset": 1742,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strlen_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1742,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strlen_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1742,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-64e3f6a0-d854-4516-aa28-5dcb58832957",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx2/memcpy_avx2.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 42,
                  "charOffset": 1753,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/memcpy_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1753,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-98f1cfdd-d2b6-49e9-a0e9-92fd6b6752c5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/strcpy/amd_strcpy.c"
                },
                "region": {
                  "startLine": 466,
                  "startColumn": 6,
                  "endLine": 466,
                  "endColumn": 34,
                  "charOffset": 16442,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strcpy/amd_strcpy.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16442,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strcpy/amd_strcpy.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16442,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-041795f5-dbab-4595-8f74-f3feca9f7962",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/strcpy_zen3.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 34,
                  "charOffset": 1800,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strcpy_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strcpy_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8751b201-9db5-44f6-a610-f2415baf5165",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/strncat_zen3.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 43,
                  "charOffset": 1813,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strncat_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strncat_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6e4372a5-7cfb-46ce-a4fb-07badcfb3f5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/memcpy_zen3.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 42,
                  "charOffset": 1793,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/memcpy_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1793,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b2e77615-f1ba-44fe-8524-4723821f150d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/strncpy_zen3.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 43,
                  "charOffset": 1822,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strncpy_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strncpy_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1822,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-35b0ed97-d845-4688-a266-95142a9cc497",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/strcat_zen3.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 34,
                  "charOffset": 1797,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strcat_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strcat_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7f5c9e2f-8e4d-4cc8-814e-d8666f00e9fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen3/strlen_zen3.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 7,
                  "endLine": 32,
                  "endColumn": 27,
                  "charOffset": 1782,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strlen_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen3/strlen_zen3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-41ec271c-af89-4011-bbeb-7b5403880787",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/strcat/amd_strcat.c"
                },
                "region": {
                  "startLine": 809,
                  "startColumn": 6,
                  "endLine": 809,
                  "endColumn": 34,
                  "charOffset": 26372,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strcat/amd_strcat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26372,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strcat/amd_strcat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26372,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c3079594-390e-455a-9c2a-47069acc9cf3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/strncpy_zen4.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 43,
                  "charOffset": 1828,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strncpy_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1828,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strncpy_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1828,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-09716415-a345-4896-a23c-bab69f48ede4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/strlen_zen4.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 7,
                  "endLine": 32,
                  "endColumn": 27,
                  "charOffset": 1788,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strlen_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strlen_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-85c617ce-6f19-43ff-9594-dfbd0e000fc0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/memcpy_zen4.c"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 6,
                  "endLine": 118,
                  "endColumn": 42,
                  "charOffset": 4613,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/memcpy_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4613,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fbbd28db-58c8-40e5-ad18-0879cbd2f703",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/strncat_zen4.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 43,
                  "charOffset": 1813,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strncat_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strncat_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe44d8bc-d4a8-4423-955b-8498f88d3c44",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/strlen_avx512.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 7,
                  "endLine": 31,
                  "endColumn": 27,
                  "charOffset": 1748,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strlen_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1748,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strlen_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1748,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cf8d5aa5-f1ab-4fda-b60b-af6ac5592a1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/strncpy/amd_strncpy.c"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 6,
                  "endLine": 643,
                  "endColumn": 43,
                  "charOffset": 21086,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strncpy/amd_strncpy.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21086,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strncpy/amd_strncpy.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21086,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0026fe4a-243f-476a-b007-e20001ef84d6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/strcpy_zen4.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 34,
                  "charOffset": 1806,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strcpy_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1806,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strcpy_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1806,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4376c0e3-4bc2-4bd9-8579-53ffa146c3e6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/strncat_avx512.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 6,
                  "endLine": 31,
                  "endColumn": 43,
                  "charOffset": 1779,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strncat_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1779,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strncat_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1779,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ec36fce4-fc2a-4f7a-9b47-b4c02901a5af",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/strcpy_avx512.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 34,
                  "charOffset": 1766,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strcpy_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1766,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strcpy_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1766,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9844e888-15bf-432a-b16d-eb38b3a3319a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/strlen/amd_strlen.c"
                },
                "region": {
                  "startLine": 378,
                  "startColumn": 7,
                  "endLine": 378,
                  "endColumn": 27,
                  "charOffset": 11590,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strlen/amd_strlen.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11590,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/strlen/amd_strlen.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11590,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b63f5563-be59-4b0d-94e5-916286823474",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/strncpy_avx512.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 43,
                  "charOffset": 1788,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strncpy_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strncpy_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0ba6aaff-c896-47c7-9f40-ca16eed8de3e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen4/strcat_zen4.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 34,
                  "charOffset": 1803,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strcat_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1803,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen4/strcat_zen4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1803,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49dc6da2-3d13-490c-983c-fe6529d15377",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/memcpy_avx512.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 42,
                  "charOffset": 1827,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/memcpy_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1827,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6ba44cd6-79f5-45ad-9798-631b98f2e85a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx512/strcat_avx512.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 6,
                  "endLine": 31,
                  "endColumn": 34,
                  "charOffset": 1763,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strcat_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1763,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx512/strcat_avx512.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1763,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3bc87ec3-edef-459e-bdb4-ae6fcba404ac",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/strcpy_zen2.c"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 6,
                  "endLine": 35,
                  "endColumn": 34,
                  "charOffset": 1800,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strcpy_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strcpy_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a335c402-f937-48c2-852a-62967eb05523",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx2/strncat_avx2.c"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 6,
                  "endLine": 31,
                  "endColumn": 43,
                  "charOffset": 1773,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strncat_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1773,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strncat_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1773,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6224e9aa-253f-47ec-8871-4a5ab3403060",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/strncat_zen2.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 43,
                  "charOffset": 1813,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncat(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncat(char *, const char *, size_t)",
                      "markdown": "`strncat(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strncat_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strncat_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1813,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e50a81b3-c90b-4f67-9526-77b188ab3ef5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx2/strcpy_avx2.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 34,
                  "charOffset": 1760,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcpy(char *, const char *)",
                    "rendered": {
                      "text": "strcpy(char *, const char *)",
                      "markdown": "`strcpy(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strcpy_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1760,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strcpy_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1760,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-723af476-f42a-4340-bfbc-94d268a959b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/strlen_zen2.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 7,
                  "endLine": 32,
                  "endColumn": 27,
                  "charOffset": 1782,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(const char *)",
                    "rendered": {
                      "text": "strlen(const char *)",
                      "markdown": "`strlen(const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strlen_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strlen_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(const char *, <size of const char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7ea47f1-3b30-4ef4-9774-7f1b21da403a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/isa/avx2/strncpy_avx2.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 43,
                  "charOffset": 1782,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(char *, const char *, size_t)",
                    "rendered": {
                      "text": "strncpy(char *, const char *, size_t)",
                      "markdown": "`strncpy(char *, const char *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strncpy_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char *,  size_t,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/isa/avx2/strncpy_avx2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1782,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(char *,  const char *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cf72d9d3-2602-4ae0-b192-7a403b2fb1e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/memcpy/amd_memcpy.c"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 6,
                  "endLine": 209,
                  "endColumn": 42,
                  "charOffset": 7561,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(void *, const void *, size_t)",
                    "rendered": {
                      "text": "memcpy(void *, const void *, size_t)",
                      "markdown": "`memcpy(void *, const void *, size_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/memcpy/amd_memcpy.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7561,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(void *, <size of void *>,  const void *,  size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ff8b87bf-a676-4274-98d5-3f8c82e2e188",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/uarch/zen2/strcat_zen2.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 34,
                  "charOffset": 1797,
                  "charLength": 28,
                  "snippet": {
                    "text": "strcat(char *, const char *)",
                    "rendered": {
                      "text": "strcat(char *, const char *)",
                      "markdown": "`strcat(char *, const char *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strcat_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strcat_s(char *, <size of char *>,  const char *)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If the combination of strings is larger than the destination buffer, strcat will cbuffer overflow the destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/uarch/zen2/strcat_zen2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1797,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlcat(char *,  const char *, <size of char *>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}